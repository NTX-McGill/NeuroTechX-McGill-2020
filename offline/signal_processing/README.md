# Signal Processing

## Dependencies
* [Python 3.7.6](https://www.python.org/downloads/) or later
* [Numpy 1.18.1](https://numpy.org/) or later
* [Matplotlib 3.1.3](https://matplotlib.org/) or later
* [Pandas 1.0.3](https://pandas.pydata.org/) or later
* [Scipy 1.4.1](https://www.scipy.org/) or later

## EMG Signals
Electromyography (EMG) signals are noisy, non-stationary, and complex.

### Filtering

Based on prior experience with neurological signals, we opted to use Infinite Impluse Response (IIR) filters. 
Surface EMG signals can lie anywhere in the 5-450 Hz frequency range; however, due to having a sampling rate limitation of only 250 Hz, we were unable to explore higher frequencies values.
In order to denoise a signal, we first notch filter the EMG signal at 60 Hz to remove powerline interference, then we apply a 4th order Butterworth Bandpass filter the signal to keep the frequency range of interest.

![alt text](./figures/unfiltered.png)
![alt text](./figures/notch_filtered.png)
![alt text](./figures/notch_and_bandpass_filtered.png)

Much of the options we explored involved finding the ideal frequency band for our purposes.
Through our experiments, we found the 5-50 Hz range produceed the best results with our models.
Another detail we adjusted was finding a sufficient quality factor to use for the notch filter.
At first we relied on values of 4 and 15 but we ultimately chose to use a factor of 60.

### Signal Formatting

We developped two different formatting procedures, depending on whether the data was received "offline" or "online".
The former refers to data received through a data collection trial. 
We call it "offline" because we stored the entire signal for analysis and training our models.
The latter refers to data received while actually running the armband, hence it is data we must process while the armband is "online".

#### Offline Training

Offline data is split into two files: one containing the raw EMG signals generated by the OpenBCI GUI and one containing the timestamped labels of finger movements generated by us.
Since offline data is stored, we can filter the entire signal at once.
However, to train a model to classify these signals, the raw EMG data needed to be labelled and segmented into overlapping windows.
This means we need to map the labels to the signal sample points.
Essentially, the steps are as follows (for more details, refer to the files `match_labels.py` and `windowing_helpers.py`):

1. Initialize all window labels as baseline events.
2. If a window is within a certain timeframe of a timestamped label, the window receives the given label.
3. To reduce misclassification, we calculate the Power Spectral Density (PSD) of each channel and if none exceed a threshold, we relabel the window as baseline.

#### Online Performance

Unlike offline data, after the online passes through the model, it is discarded.
Therefore we cannot filter online data in a single pass.
Moreover, due to the windows overlapping, we also couldn't simply filter the windows in batches, or else we'd have filtering artifacts at the start of every window!
In light of this, for online data we filter the signal point-by-point and store the state of the signal coefficients at the start of the overlap between successive windows.
This way we can correctly filter incoming windows as if we were doing it offline.

The specific differences between the implementations of offline filter, which we call the `'original_filter'`, and the online filter, which we call the `'real_time_filter'`, can be seen in the file `filtering.py`.

